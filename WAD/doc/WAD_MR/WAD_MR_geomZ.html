<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of WAD_MR_geomZ</title>
  <meta name="keywords" content="WAD_MR_geomZ">
  <meta name="description" content="------------------------------------------------------------------------">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- menu.html WAD_MR -->
<h1>WAD_MR_geomZ
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>------------------------------------------------------------------------</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function WAD_MR_geomZ( i_iSeries, sSeries, sParams ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> ------------------------------------------------------------------------
 WAD_MR is an MRI analysis module written for IQC.
 NVKF WAD IQC software is a framework for automatic analysis of DICOM objects.
 
 Copyright 2012-2013  Joost Kuijer / jpa.kuijer@vumc.nl
 
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 ------------------------------------------------------------------------</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../WAD/WAD_ErrorMsg.html" class="code" title="function WAD_ErrorMsg( name, mymessage, err )">WAD_ErrorMsg</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_resultsAppendFigure.html" class="code" title="function WAD_resultsAppendFigure( level, handle, tag, description )">WAD_resultsAppendFigure</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_resultsAppendFloat.html" class="code" title="function WAD_resultsAppendFloat( level, value, variable, unit, description, sLimits, limits_field_name )">WAD_resultsAppendFloat</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_resultsAppendString.html" class="code" title="function WAD_resultsAppendString( level, value, description )">WAD_resultsAppendString</a>	------------------------------------------------------------------------</li><li><a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>	------------------------------------------------------------------------</li><li><a href="../WAD/myErrordlg.html" class="code" title="function h = myErrordlg(isInteractive,varargin)">myErrordlg</a>	------------------------------------------------------------------------</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)</a></li><li><a href="#_sub2" class="code">function centerpixel = find_center_row(linesum,pixelspacing)</a></li><li><a href="#_sub3" class="code">function centerpixel = find_center_column(linesum,pixelspacing)</a></li><li><a href="#_sub4" class="code">function zerocross_pix = find_zerocrossing_pix( x )</a></li><li><a href="#_sub5" class="code">function [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)</a></li><li><a href="#_sub6" class="code">function [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% ------------------------------------------------------------------------</span>
0002 <span class="comment">% WAD_MR is an MRI analysis module written for IQC.</span>
0003 <span class="comment">% NVKF WAD IQC software is a framework for automatic analysis of DICOM objects.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Copyright 2012-2013  Joost Kuijer / jpa.kuijer@vumc.nl</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% This program is free software: you can redistribute it and/or modify</span>
0009 <span class="comment">% it under the terms of the GNU General Public License as published by</span>
0010 <span class="comment">% the Free Software Foundation, either version 3 of the License, or</span>
0011 <span class="comment">% (at your option) any later version.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% This program is distributed in the hope that it will be useful,</span>
0014 <span class="comment">% but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
0015 <span class="comment">% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
0016 <span class="comment">% GNU General Public License for more details.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% You should have received a copy of the GNU General Public License</span>
0019 <span class="comment">% along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
0020 <span class="comment">% ------------------------------------------------------------------------</span>
0021 
0022 <a name="_sub0" href="#_subfunctions" class="code">function WAD_MR_geomZ( i_iSeries, sSeries, sParams )</a>
0023 <span class="comment">% Evaluate length of phantom in head-feet direction on mid-saggital slice (the actual length is 148 mm)</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% Input: SAG series on ACR phantom, for best results tilt 2 - 5 degrees (edge pixel subsampling)</span>
0026 <span class="comment">%        Analysis is performed on first image in series</span>
0027 <span class="comment">%        Parameters: none</span>
0028 <span class="comment">%</span>
0029 <span class="comment">% Output: written via WAD_resultsAppend*() interface</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% This module consists of the following seven steps:</span>
0032 <span class="comment">% 1. Calculation of the row APPROXIMATELY centered in the middle of the phantom (&quot;center row&quot;)</span>
0033 <span class="comment">%    1. the image intensities along each row are summed</span>
0034 <span class="comment">%    2. the gradient of summed intensities is calculated</span>
0035 <span class="comment">%    3. the &quot;upper row&quot; is the max after multiplying the gradient with a function to find a positive step</span>
0036 <span class="comment">%    4. the &quot;lower row&quot; is the min after multiplying the gradient with a function to fing a negative step</span>
0037 <span class="comment">%    The &quot;center row&quot; will be used for</span>
0038 <span class="comment">%    - help finding the &quot;center column&quot;</span>
0039 <span class="comment">%    - for finding the precise edges a given distance interval above and below the &quot;center row&quot;</span>
0040 <span class="comment">%      (to minimize the chance of detecting wrong edges)</span>
0041 <span class="comment">%</span>
0042 <span class="comment">% 2. Calculation of the column APPROXIMATELY centered in the middle of the phantom (&quot;center column&quot;)</span>
0043 <span class="comment">%    It is used that a vertical &quot;hole&quot; aligned in the middle is present in the lower half of the phantom.</span>
0044 <span class="comment">%    1. the image intensities below the &quot;center row&quot; along each column are summed</span>
0045 <span class="comment">%    2. the &quot;center column&quot; is the maximum after multiplying the summed</span>
0046 <span class="comment">%       intensities with a function to find a symmetric minimum.</span>
0047 <span class="comment">%    The &quot;center column&quot; will be used for horizontal cropping of the binary edge image.</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% 3. Edge detection in horizontal direction.</span>
0050 <span class="comment">%      All edges with a direction significantly different from vertical will be detected.</span>
0051 <span class="comment">%      The result is a binary image.</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% 4. Cropping of the binary image in horizontal direction to the &quot;center column&quot; plus and minus 45 mm</span>
0054 <span class="comment">%      Cropping is done for two reasons:</span>
0055 <span class="comment">%      1. A more unambiguous assignment of distance between edges in case these edges are curved.</span>
0056 <span class="comment">%      2. In the upper left corner a second edge (few millimeter lower than &quot;real&quot; edge) might also be detected.</span>
0057 <span class="comment">%         This unwanted edge can be aligned (towards the right) with the real edge in case this real edge is curved,</span>
0058 <span class="comment">%         giving rise to an unwanted peak in the Radon matrix.</span>
0059 <span class="comment">%      The cropped region is visualized in the output by vertical blue lines.</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% 5. Radon transform</span>
0062 <span class="comment">%      Lines (or aligned line segments) in the cropped binary image are found by means of a Radon transform.</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% 6. Detection of two lines (or aligned line segments)</span>
0065 <span class="comment">%      Hereafter, &quot;shift&quot; (either positive or negative) corresponds to the difference between</span>
0066 <span class="comment">%      the &quot;center row&quot; of the phantom and the center row of the image.</span>
0067 <span class="comment">%      1. Most pronounced straight line (or aligned line segments), for which</span>
0068 <span class="comment">%       - shortest distance between line and center pixel is between 65+shift and 85+shift mm</span>
0069 <span class="comment">%       - the point along the line closest to the center pixel is ABOVE the center row of the phantom.</span>
0070 <span class="comment">%      2. Most pronounced straight line (or aligned line segments), for which (&quot;shift&quot; has now opposite sign)</span>
0071 <span class="comment">%       - shortest distance between line and center pixel is between 65+shift and 85+shift mm</span>
0072 <span class="comment">%       - the point along the line closest to the center pixel is BELOW the center row of the phantom</span>
0073 <span class="comment">%      The lines (corresponding to edges in the original image) are visualized in the output by red lines.</span>
0074 <span class="comment">%</span>
0075 <span class="comment">% 7. Calculation of length of phantom.</span>
0076 <span class="comment">%      This length equals the sum of the two &quot;shortest distances&quot;.</span>
0077 <span class="comment">%      For parallel lines, this corresponds to the distance between the lines.</span>
0078 <span class="comment">%      It is always a distance corresponding to a multiple of one pixel, also for rotated and curved edges.</span>
0079 <span class="comment">%      (this is a property of the Radon transform)</span>
0080 <span class="comment">%      Each shortest distance (center pixel - edge) is visualized in the output by a red line.</span>
0081 <span class="comment">%</span>
0082 <span class="comment">% ------------------------------------------------------------------------</span>
0083 <span class="comment">% WAD MR</span>
0084 <span class="comment">% file: WAD_MR_geomZ</span>
0085 <span class="comment">% ------------------------------------------------------------------------</span>
0086 <span class="comment">% VUmc, Amsterdam, NL / Frank de Weerd &amp; Joost Kuijer / jpa.kuijer@vumc.nl</span>
0087 <span class="comment">% 2009-05-13 / JK</span>
0088 <span class="comment">% second version</span>
0089 <span class="comment">% ------------------------------------------------------------------------</span>
0090 <span class="comment">% JK - 090925 v2.1: modified the algorithm</span>
0091 <span class="comment">% - use gradient image instead of binary edge</span>
0092 <span class="comment">% - use zero-crossing of derivative to find position of maximum in Radon</span>
0093 <span class="comment">% transform. This allows (linear) interpolation.</span>
0094 <span class="comment">% ------------------------------------------------------------------------</span>
0095 <span class="comment">% JK - 20120807 v2.1: adapted to WAD framework</span>
0096 <span class="comment">% ------------------------------------------------------------------------</span>
0097 <span class="comment">% JK - 20120807 v2.2: new (v1.1) style action limits</span>
0098 <span class="comment">% ------------------------------------------------------------------------</span>
0099 <span class="comment">% JK - 20170726 v2.3: rename result 'Geometrie Z' to 'Geometrie Z series'</span>
0100 <span class="comment">% ------------------------------------------------------------------------</span>
0101 
0102 <span class="comment">% produce a figure on the screen or be quiet...</span>
0103 quiet = true;
0104 isInteractive = false;
0105 
0106 <span class="comment">% version info</span>
0107 my.name = <span class="string">'WAD_MR_geomZ'</span>;
0108 my.version = <span class="string">'2.3'</span>;
0109 my.date = <span class="string">'20170726'</span>;
0110 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [<span class="string">'Module '</span> my.name <span class="string">' Version '</span> my.version <span class="string">' ('</span> my.date <span class="string">')'</span>] );
0111 
0112 <span class="comment">%gen_object_display( sSeries );</span>
0113 <span class="comment">%gen_object_display( sParams );</span>
0114 
0115 
0116 <span class="comment">% select the image within the series</span>
0117 inum = 1; <span class="comment">% there should be only 1 image...</span>
0118 
0119 
0120 <span class="comment">% find the image</span>
0121 foundImage = false;
0122 <span class="keyword">for</span> ii = 1:length( sSeries.instance )
0123     <span class="keyword">if</span> ( sSeries.instance(ii).number == inum )
0124         ci = ii;
0125         foundImage = true;
0126         <span class="keyword">break</span>;
0127     <span class="keyword">end</span>
0128 <span class="keyword">end</span>
0129 <span class="keyword">if</span> ~foundImage
0130     <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">': Error: could not find image number '</span> num2str( inum ) <span class="string">' for geometry Z'</span>], 1 );
0131     <a href="../WAD/myErrordlg.html" class="code" title="function h = myErrordlg(isInteractive,varargin)">myErrordlg</a>( isInteractive, [<span class="string">'Cannot find configured image number '</span> num2str( inum ) <span class="string">' for geometry Z evaluation.'</span>], <span class="string">'Geometry Z'</span>, <span class="string">'on'</span> );
0132     <span class="keyword">return</span>;
0133 <span class="keyword">end</span>
0134 
0135 <span class="comment">% display waitbar in interactive mode</span>
0136 <span class="keyword">if</span> isInteractive, h = waitbar( 0, <span class="string">'Calculating geometry Z'</span> ); <span class="keyword">end</span>
0137 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">': Calculating geometry Z ...'</span>] );
0138 
0139 <span class="comment">% read the DICOM image</span>
0140 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   loading DICOM image file: '</span> sSeries.instance(ci).filename ] );
0141 <span class="keyword">try</span>
0142     dcmInfo = dicominfo( sSeries.instance(ci).filename );
0143 <span class="keyword">catch</span> err
0144     <a href="../WAD/WAD_ErrorMsg.html" class="code" title="function WAD_ErrorMsg( name, mymessage, err )">WAD_ErrorMsg</a>( my.name, [<span class="string">'ERROR reading DICOM info from file &quot;'</span> sSeries.instance(ci).filename <span class="string">'&quot;)'</span>], err );
0145     <span class="keyword">return</span>
0146 <span class="keyword">end</span>
0147 <span class="keyword">try</span>
0148     a = dicomread( dcmInfo );
0149 <span class="keyword">catch</span> err
0150     <a href="../WAD/WAD_ErrorMsg.html" class="code" title="function WAD_ErrorMsg( name, mymessage, err )">WAD_ErrorMsg</a>( my.name, [<span class="string">'ERROR reading pixel data from DICOM file &quot;'</span> sSeries.instance(ci).filename <span class="string">'&quot;)'</span>], err );
0151     <span class="keyword">return</span>
0152 <span class="keyword">end</span>
0153 
0154 
0155 <span class="comment">%warndlg('Testcase CT fantoom: removing bottom part of image');</span>
0156 <span class="comment">%a(400:end,:)=0;</span>
0157 
0158 <span class="comment">% check that pixel size is square</span>
0159 dcmPxSp = dcmInfo.PixelSpacing;
0160 <span class="keyword">if</span> dcmPxSp(1) ~= dcmPxSp(2)
0161     <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">': Error: pixel size not equal in row and column direction. Currently not supported.'</span>] );
0162     <a href="../WAD/myErrordlg.html" class="code" title="function h = myErrordlg(isInteractive,varargin)">myErrordlg</a>( isInteractive, <span class="string">'Pixel size not equal in row and column direction. Currently not supported.'</span>, <span class="string">'Geometry Z'</span>, <span class="string">'on'</span> );
0163     <span class="keyword">return</span>;
0164 <span class="keyword">end</span>
0165 pixelspacing = dcmPxSp(1);
0166 
0167 <span class="comment">% JK - interpolate pixels to reduce discretisation of length measurement</span>
0168 <span class="comment">%WAD_vbprint( [my.name ':  starting interpolation'] );</span>
0169 <span class="comment">%a = interp2(a,1,'cubic');</span>
0170 <span class="comment">%pixelspacing = pixelspacing / 2;</span>
0171 
0172 image_dimension = size(a);
0173 largest_dimension = max(image_dimension);
0174 
0175 <span class="comment">% 1. find the APPROXIMATE center row</span>
0176 sum_over_columns = zeros( 1, image_dimension(1) );
0177 <span class="keyword">for</span> i=1:image_dimension(1),
0178     sum_over_columns(i) = sum(a(i,:));
0179 <span class="keyword">end</span>
0180 approx_center_row_pix = <a href="#_sub2" class="code" title="subfunction centerpixel = find_center_row(linesum,pixelspacing)">find_center_row</a>(sum_over_columns,pixelspacing);   
0181 
0182 <span class="comment">% 2. find the APPROXIMATE center column</span>
0183 sum_over_rows = zeros( 1, image_dimension(2) );
0184 <span class="keyword">for</span> i=1:image_dimension(2),
0185       sum_over_rows(i) = sum(a(approx_center_row_pix:image_dimension(1),i));
0186 <span class="keyword">end</span>
0187 approx_center_column_pix = <a href="#_sub3" class="code" title="subfunction centerpixel = find_center_column(linesum,pixelspacing)">find_center_column</a>(sum_over_rows,pixelspacing);
0188 
0189 <span class="comment">%warndlg('Testcase: fix center row/col');</span>
0190 <span class="comment">%sim testcase: approx_center_row_pix = 256; approx_center_column_pix = 256;</span>
0191 <span class="comment">%CT GE testcase:</span>
0192 <span class="comment">%approx_center_row_pix = 221; approx_center_column_pix = 246;</span>
0193 
0194 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   estimated approximate centre at row '</span> num2str(approx_center_row_pix) <span class="string">' and col '</span> num2str(approx_center_column_pix)] );
0195 
0196 
0197 <span class="comment">% 3. Edge detection</span>
0198 <span class="comment">% JK - 090925: use gradient image instead of binary edge image</span>
0199 <span class="comment">% bw = edge(a,'Sobel','horizontal');  % 'Prewitt' gives similar results</span>
0200 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   calculating gradient image'</span>] );
0201 [gx,gy] = gradient( double(a) );
0202 bw = sqrt( gx.^2 + gy.^2 ); <span class="comment">% magnitude of gradient</span>
0203 <span class="comment">%figure; colormap(gray(256)); image(bw)</span>
0204 
0205 
0206 <span class="comment">% update waitbar in interactive mode</span>
0207 <span class="keyword">if</span> isInteractive, waitbar( 0.3, h ); <span class="keyword">end</span>
0208 
0209 
0210 <span class="comment">% 4. Make a cropped image</span>
0211 <span class="comment">%    Consider only the middle part (45 mm left to 45 mm right)</span>
0212 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   cropping image'</span>] );
0213 start = round(approx_center_column_pix - 25/pixelspacing);
0214 stop  = round(approx_center_column_pix + 45/pixelspacing);
0215 
0216 <span class="comment">% Make vertical blue lines to show which part is selected</span>
0217 x_blueline1 = [start,start];
0218 y_blueline1 = [1,image_dimension(1)];
0219 x_blueline2 = [stop,stop];
0220 y_blueline2 = [1,image_dimension(1)];
0221 
0222 bw2=bw;
0223 <span class="keyword">for</span> i=1:start,
0224     <span class="keyword">for</span> j=1:image_dimension(1),
0225         bw2(j,i)=0;
0226     <span class="keyword">end</span>
0227 <span class="keyword">end</span>
0228 
0229 <span class="keyword">for</span> i=stop:image_dimension(2),
0230     <span class="keyword">for</span> j=1:image_dimension(1),
0231         bw2(j,i)=0;
0232     <span class="keyword">end</span>
0233 <span class="keyword">end</span>
0234 
0235 <span class="comment">% update waitbar in interactive mode</span>
0236 <span class="keyword">if</span> isInteractive, waitbar( 0.5, h ); <span class="keyword">end</span>
0237 
0238 <span class="comment">%figure; colormap(gray(256)); image(bw2)</span>
0239 
0240 <span class="comment">% 5. Radon transform</span>
0241 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   calculating Radon transform'</span>] );
0242 theta = 70:0.5:110;                  <span class="comment">% steps of 0.5 degrees are chosen (this is somewhat arbitrarily)</span>
0243 [R,xp] = radon(bw2,theta);
0244 
0245 <span class="comment">%figure; imshow(R,[]);</span>
0246 
0247 <span class="comment">% update waitbar in interactive mode</span>
0248 <span class="keyword">if</span> isInteractive, waitbar( 0.8, h ); <span class="keyword">end</span>
0249 
0250 <span class="comment">%figure; imagesc(theta, xp, R); colormap(hot);</span>
0251 <span class="comment">%xlabel('\theta (degrees)'); ylabel('x\prime');</span>
0252 <span class="comment">%title('R_{\theta} (x\prime)');</span>
0253 <span class="comment">%colorbar</span>
0254 
0255 <span class="comment">% 6. Find the peaks in the Radon matrix</span>
0256 <span class="comment">%    An edge in the upper half of the image corresponds to a peak in the lower</span>
0257 <span class="comment">%    half of the Radon matrix.</span>
0258 <a href="../WAD/WAD_vbprint.html" class="code" title="function WAD_vbprint( arg, level )">WAD_vbprint</a>( [my.name <span class="string">':   finding peaks in Radon space'</span>] );
0259 middle_xp_pix = find(xp==0);
0260 ApproxZshift_pix = image_dimension(1)/2 - approx_center_row_pix;    <span class="comment">% negative means a downshift</span>
0261 
0262 <span class="comment">% Find the peak corresponding to the upper edge</span>
0263 StartUpper_pix = middle_xp_pix + round(ApproxZshift_pix) + round(65/pixelspacing);
0264 StopUpper_pix  = middle_xp_pix + round(ApproxZshift_pix) + round(85/pixelspacing);
0265 [UpperDistance_pix, Theta_Upper_deg] = <a href="#_sub1" class="code" title="subfunction [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)">find_the_peak</a>(R,xp,theta,StartUpper_pix,StopUpper_pix);
0266 
0267 <span class="comment">% Find the peak corresponding to the lower edge</span>
0268 StartLower_pix = middle_xp_pix + round(ApproxZshift_pix) - round(85/pixelspacing);
0269 StopLower_pix  = middle_xp_pix + round(ApproxZshift_pix) - round(65/pixelspacing);
0270 [LowerDistance_pix, Theta_Lower_deg] = <a href="#_sub1" class="code" title="subfunction [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)">find_the_peak</a>(R,xp,theta,StartLower_pix,StopLower_pix);
0271 
0272 <span class="comment">% 7. Calculate the size of the phantom along its longitudinal axis</span>
0273 Zsize_pix = UpperDistance_pix - LowerDistance_pix;
0274 
0275 lengthZ_mm = Zsize_pix * pixelspacing;
0276 rotationSAG_deg = 0.5 .* (Theta_Upper_deg + Theta_Lower_deg) - 90;
0277 
0278 <a href="../WAD/WAD_resultsAppendFloat.html" class="code" title="function WAD_resultsAppendFloat( level, value, variable, unit, description, sLimits, limits_field_name )">WAD_resultsAppendFloat</a>( 1, lengthZ_mm, <span class="string">'Lengte'</span>, <span class="string">'mm'</span>, <span class="string">'Geometrie Z'</span> );
0279 <a href="../WAD/WAD_resultsAppendFloat.html" class="code" title="function WAD_resultsAppendFloat( level, value, variable, unit, description, sLimits, limits_field_name )">WAD_resultsAppendFloat</a>( 1, rotationSAG_deg, <span class="string">'Rotatie'</span>, <span class="string">'graden'</span>, <span class="string">'Geometrie Z'</span> );
0280 
0281 <span class="comment">%handles.results.lengthZ_mm</span>
0282 
0283 <span class="comment">% close waitbar in interactive mode</span>
0284 <span class="keyword">if</span> isInteractive, close( h ), <span class="keyword">end</span>
0285 
0286 
0287 <span class="comment">% In the matlab help, it can be found that the center pixel of image I in the Radon transformation is defined to be floor((size(I)+1)/2)</span>
0288 CenterPixel = floor((size(a)+1)/2);
0289 
0290 [x_edge_upper, y_edge_upper] = <a href="#_sub5" class="code" title="subfunction [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)">draw_the_edge</a>(CenterPixel,largest_dimension,UpperDistance_pix,Theta_Upper_deg);
0291 [x_edge_lower, y_edge_lower] = <a href="#_sub5" class="code" title="subfunction [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)">draw_the_edge</a>(CenterPixel,largest_dimension,LowerDistance_pix,Theta_Lower_deg);
0292 [x_distance_upper, y_distance_upper] = <a href="#_sub6" class="code" title="subfunction [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)">draw_the_distance</a>(CenterPixel,UpperDistance_pix,Theta_Upper_deg);
0293 [x_distance_lower, y_distance_lower] = <a href="#_sub6" class="code" title="subfunction [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)">draw_the_distance</a>(CenterPixel,LowerDistance_pix,Theta_Lower_deg);
0294 
0295 <span class="comment">% Draw all lines in the images</span>
0296 <span class="comment">% create figure</span>
0297 <span class="keyword">if</span> quiet 
0298     fig_visible = <span class="string">'off'</span>;
0299 <span class="keyword">else</span>
0300     fig_visible = <span class="string">'on'</span>;
0301 <span class="keyword">end</span>
0302 
0303 <span class="comment">% create figure</span>
0304 hFig1 = figure( <span class="string">'Visible'</span>, fig_visible, <span class="string">'MenuBar'</span>, <span class="string">'none'</span>, <span class="string">'Name'</span>, <span class="string">'Geometry Z'</span> );
0305 colormap( gray(256) );
0306 imagesc( a );
0307 axis image
0308 axis square
0309 axis off
0310 title( [ <span class="string">'series '</span> num2str(sSeries.number) <span class="string">' - image '</span> num2str(sSeries.instance(ci).number)], <span class="string">'Interpreter'</span>, <span class="string">'none'</span> );
0311 
0312 <span class="comment">%figure; colormap(gray(256)); imagesc(a);</span>
0313 
0314 hold on
0315 
0316 plot(x_edge_upper,y_edge_upper,<span class="string">'r-'</span>);
0317 plot(x_distance_upper,y_distance_upper,<span class="string">'r-'</span>);
0318 plot(x_edge_lower,y_edge_lower,<span class="string">'r-'</span>);
0319 plot(x_distance_lower,y_distance_lower,<span class="string">'r-'</span>);
0320 plot(x_blueline1,y_blueline1,<span class="string">'b-'</span>);
0321 plot(x_blueline2,y_blueline2,<span class="string">'b-'</span>);
0322 
0323 hold off
0324 
0325 
0326 <span class="comment">% Write figure to level 2</span>
0327 <a href="../WAD/WAD_resultsAppendString.html" class="code" title="function WAD_resultsAppendString( level, value, description )">WAD_resultsAppendString</a>( 2, [<span class="string">'Analysis on series: '</span> num2str(sSeries.number) <span class="string">' / image: '</span> num2str(inum) ], <span class="string">'Geometrie Z series'</span> )
0328 <a href="../WAD/WAD_resultsAppendFigure.html" class="code" title="function WAD_resultsAppendFigure( level, handle, tag, description )">WAD_resultsAppendFigure</a>( 2, hFig1, <span class="string">'geomZ_fitted'</span>, <span class="string">'Geometrie Z: randdetectie'</span> );
0329 <span class="keyword">if</span> quiet
0330     <span class="comment">% delete non-visible image</span>
0331     delete( hFig1 );
0332 <span class="keyword">end</span>
0333 
0334 
0335 <span class="comment">% create figure</span>
0336 hFig2 = figure( <span class="string">'Visible'</span>, fig_visible, <span class="string">'MenuBar'</span>, <span class="string">'none'</span>, <span class="string">'Name'</span>, <span class="string">'SNR / Ghosting'</span> );
0337 colormap( gray(256) );
0338 image( bw )
0339 axis image
0340 axis square
0341 axis off
0342 title( [ <span class="string">'series '</span> num2str(sSeries.number) <span class="string">' - image '</span> num2str(sSeries.instance(ci).number)], <span class="string">'Interpreter'</span>, <span class="string">'none'</span> );
0343 <span class="comment">%figure; colormap(gray(2)); image(bw)</span>
0344 
0345 hold on
0346 
0347 plot(x_edge_upper,y_edge_upper,<span class="string">'r-'</span>);
0348 plot(x_distance_upper,y_distance_upper,<span class="string">'r-'</span>);
0349 plot(x_edge_lower,y_edge_lower,<span class="string">'r-'</span>);
0350 plot(x_distance_lower,y_distance_lower,<span class="string">'r-'</span>);
0351 plot(x_blueline1,y_blueline1,<span class="string">'b-'</span>);
0352 plot(x_blueline2,y_blueline2,<span class="string">'b-'</span>);
0353 
0354 hold off;
0355 
0356 <span class="comment">% Write figure to level 2</span>
0357 <a href="../WAD/WAD_resultsAppendFigure.html" class="code" title="function WAD_resultsAppendFigure( level, handle, tag, description )">WAD_resultsAppendFigure</a>( 2, hFig2, <span class="string">'geomZ_thresholded'</span>, <span class="string">'Geometrie Z: randdetectie (edge image)'</span> );
0358 <span class="keyword">if</span> quiet
0359     <span class="comment">% delete non-visible image</span>
0360     delete( hFig2 );
0361 <span class="keyword">end</span>
0362 
0363 
0364 
0365 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%%%</span>
0366 <a name="_sub1" href="#_subfunctions" class="code">function [distance_pix, Theta_deg] = find_the_peak(R,xp,theta,start_pix,stop_pix)</a>
0367 <span class="comment">% JK - 090925: use zero-crossing of derivative instead of maximum.</span>
0368 <span class="comment">%figure; imshow(R(start_pix:stop_pix,:),[]);</span>
0369 
0370 <span class="comment">%[MaxPerTheta_vector LocationMaxPerTheta_vector] = max(R(start_pix:stop_pix,:));</span>
0371 [GlobalMax Theta_pix] = max(max(R(start_pix:stop_pix,:)));
0372 
0373 Theta_deg = theta(Theta_pix);
0374 <span class="comment">%dummy = LocationMaxPerTheta_vector(Theta_pix);</span>
0375 <span class="comment">%LocationMax_pix = dummy + start_pix - 1;</span>
0376 
0377 <span class="comment">% JK - 090925: take the pixels at the angle where the maximum is located</span>
0378 lineAtTheta = R(start_pix:stop_pix,Theta_pix);
0379 <span class="comment">%figure; plot(lineAtTheta);</span>
0380 <span class="comment">%figure; plot(gradient(lineAtTheta));</span>
0381 
0382 <span class="comment">% find the position of the maximum</span>
0383 zerocross_pix = <a href="#_sub4" class="code" title="subfunction zerocross_pix = find_zerocrossing_pix( x )">find_zerocrossing_pix</a>( gradient(lineAtTheta) );
0384 LocationMax_pix = zerocross_pix + start_pix - 1;
0385 
0386 <span class="comment">%distance_pix = xp(LocationMax_pix);</span>
0387 distance_pix = interp1( xp, LocationMax_pix);
0388 
0389 
0390 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%%%</span>
0391 <a name="_sub2" href="#_subfunctions" class="code">function centerpixel = find_center_row(linesum,pixelspacing)</a>
0392 
0393 number_of_rows = length(linesum);
0394 
0395 fx = gradient(linesum);
0396 
0397 <span class="comment">%figure; plot(linesum);</span>
0398 <span class="comment">%figure; plot(fx);</span>
0399 
0400 <span class="comment">% find smallest element larger than zero</span>
0401 n=0;
0402 <span class="keyword">for</span> i=1:number_of_rows,
0403    <span class="keyword">if</span>(linesum(i) &gt; 0)
0404       n = n + 1;
0405       <span class="keyword">if</span>( n == 1) 
0406           smallest = linesum(i);
0407       <span class="keyword">elseif</span> (linesum(i) &lt; smallest)
0408              smallest = linesum(i);    
0409       <span class="keyword">end</span>    
0410    <span class="keyword">end</span>    
0411 <span class="keyword">end</span>
0412 
0413 <span class="comment">% make zero elements equal to smallest</span>
0414 <span class="keyword">for</span> i=1:number_of_rows,
0415    <span class="keyword">if</span> (linesum(i)==0)
0416        linesum(i)= smallest;
0417    <span class="keyword">end</span>    
0418 <span class="keyword">end</span>
0419 
0420 <span class="comment">% laat een mask van plus min 10 mm lopen</span>
0421 bandwidth = round(10/pixelspacing);
0422 
0423 test_value_left  = zeros( 1, number_of_rows );
0424 test_value_right = zeros( 1, number_of_rows );
0425 <span class="keyword">for</span> i = 1 : number_of_rows
0426    test_value_left(i) = 0;
0427    test_value_right(i) = 0;
0428    <span class="keyword">for</span> j= 1:bandwidth,   
0429      <span class="keyword">if</span> (i+j &gt; number_of_rows)
0430          value_right = smallest;
0431      <span class="keyword">else</span>
0432          value_right = linesum(i+j);
0433      <span class="keyword">end</span>  
0434      <span class="keyword">if</span> (i-j &lt; 1)
0435          value_left = smallest;
0436      <span class="keyword">else</span>    
0437          value_left = linesum(i-j);
0438      <span class="keyword">end</span>    
0439      ratio_left = value_right / value_left;
0440      ratio_right = value_left / value_right;     
0441      test_value_left(i) = test_value_left(i) + ratio_left;
0442      test_value_right(i) = test_value_right(i) + ratio_right;
0443    <span class="keyword">end</span>   
0444 <span class="keyword">end</span>
0445 
0446 linesum_left  = zeros( 1, number_of_rows );
0447 linesum_right = zeros( 1, number_of_rows );
0448 <span class="keyword">for</span> i=1:number_of_rows;
0449    linesum_left(i) = fx(i)*test_value_left(i);
0450    linesum_right(i) = fx(i)*test_value_right(i);
0451 <span class="keyword">end</span>
0452 
0453 <span class="comment">% skip some pixels near edge of image...</span>
0454 skip_pix = 10;
0455 linesum_left(1:skip_pix) = 0;
0456 linesum_left(number_of_rows-skip_pix:number_of_rows) = 0;
0457 linesum_right(1:skip_pix) = 0;
0458 linesum_right(number_of_rows-skip_pix:number_of_rows) = 0;
0459 
0460 <span class="comment">%figure; plot(test_value_left);</span>
0461 <span class="comment">%figure; plot(test_value_right);</span>
0462 <span class="comment">%figure; plot(linesum_left);</span>
0463 <span class="comment">%figure; plot(linesum_right);</span>
0464 
0465 <span class="comment">% find the upper edge</span>
0466 [maximum loc_max] = max(linesum_left);
0467 
0468 <span class="comment">% find the lower edge</span>
0469 [minimum loc_min] = min(linesum_right);
0470 
0471 centerpixel = round((loc_min + loc_max)/2);
0472 
0473 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%%%</span>
0474 <a name="_sub3" href="#_subfunctions" class="code">function centerpixel = find_center_column(linesum,pixelspacing)</a>
0475 
0476 number_of_columns = length(linesum);
0477 
0478 <span class="comment">%figure; plot(linesum);</span>
0479 
0480 <span class="comment">% find smallest element larger than zero</span>
0481 n=0;
0482 <span class="keyword">for</span> i=1:number_of_columns,
0483    <span class="keyword">if</span>(linesum(i) &gt; 0)
0484       n = n + 1;
0485       <span class="keyword">if</span>( n == 1) 
0486           smallest = linesum(i);
0487       <span class="keyword">elseif</span> (linesum(i) &lt; smallest)
0488              smallest = linesum(i);    
0489       <span class="keyword">end</span>    
0490    <span class="keyword">end</span>    
0491 <span class="keyword">end</span>
0492 
0493 <span class="comment">% make zero elements equal to smallest</span>
0494 <span class="keyword">for</span> i=1:number_of_columns,
0495    <span class="keyword">if</span> (linesum(i)==0)
0496        linesum(i)= smallest;
0497    <span class="keyword">end</span>    
0498 <span class="keyword">end</span>
0499 
0500 <span class="comment">% laat een mask van plus min 30 mm lopen</span>
0501 bandbreedte = round(30/pixelspacing);
0502 
0503 test_waarde = zeros( 1, bandbreedte );
0504 <span class="keyword">for</span> i = bandbreedte + 1 : number_of_columns - bandbreedte - 1,
0505    test_waarde(i) = 0;
0506    <span class="keyword">for</span> j= 1:bandbreedte,   
0507      som = ((linesum(i-j) + linesum(i+j))/2) - linesum(i);
0508      ratio = linesum(i-j) / linesum(i+j);
0509      <span class="keyword">if</span> (ratio &gt; 1)
0510          ratio = 1/ratio;
0511      <span class="keyword">end</span>    
0512      som = som * ratio;
0513      test_waarde(i) = test_waarde(i) + som;
0514    <span class="keyword">end</span>
0515 <span class="keyword">end</span>
0516 
0517 <span class="keyword">for</span> i = number_of_columns - bandbreedte : number_of_columns,
0518    test_waarde(i) = 0;
0519 <span class="keyword">end</span>
0520        
0521 <span class="comment">%figure; plot(test_waarde);</span>
0522 
0523 <span class="comment">% find the center</span>
0524 [maximum loc_max] = max(test_waarde);
0525 
0526 centerpixel = loc_max;
0527 
0528 
0529 
0530 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%</span>
0531 <span class="comment">% find zero-crossing in a 1D array, supposed to be the 2nd derivative of</span>
0532 <span class="comment">% the image intensity (in the Radon transform)</span>
0533 <span class="comment">% Return value is 0 when crossing is not found.</span>
0534 <a name="_sub4" href="#_subfunctions" class="code">function zerocross_pix = find_zerocrossing_pix( x )</a>
0535 <span class="comment">% search the zero crossing only between the maximum and the minimum</span>
0536 [~, max_i] = max( x );
0537 [~, min_i] = min( x ); <span class="comment">% min should have higher index than max</span>
0538 
0539 <span class="comment">% check if we should be able to find a proper zero crossing</span>
0540 <span class="keyword">if</span> ( x(max_i) &lt; 0 ) || ( x(min_i) &gt; 0 )
0541     fprintf( 2, <span class="string">'ERROR in SQ_MR_geomZ: cannot find edge. No zero-crossing of 2nd derivative.'</span> );
0542     zerocross_pix = 0;
0543     <span class="keyword">return</span>
0544 <span class="keyword">end</span>
0545 <span class="comment">% find the index where the sign has changed</span>
0546 <span class="keyword">for</span> ii = max_i:min_i
0547     <span class="keyword">if</span> x(ii) &lt; 0, <span class="keyword">break</span>, <span class="keyword">end</span>
0548 <span class="keyword">end</span>
0549 <span class="comment">% interpolate between pixels</span>
0550 zerocross_pix = (ii-1) + x(ii-1) ./ ( x(ii-1) - x(ii) );
0551 
0552 
0553 
0554 
0555 
0556 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%</span>
0557 <span class="comment">% Turn the found edge into a red line</span>
0558 <a name="_sub5" href="#_subfunctions" class="code">function [x,y] = draw_the_edge(CenterPixel,largest_dimension,Distance_pix,Theta_deg)</a>
0559 
0560 x(1) = CenterPixel(2) - largest_dimension .* sin(2*pi*Theta_deg/360);
0561 x(2) = CenterPixel(2) + largest_dimension .* sin(2*pi*Theta_deg/360);
0562 y(1) = CenterPixel(1) - largest_dimension .* cos(2*pi*Theta_deg/360);
0563 y(2) = CenterPixel(1) + largest_dimension .* cos(2*pi*Theta_deg/360);
0564 
0565 x = x + Distance_pix .* cos(2*pi*Theta_deg/360);
0566 y = y - Distance_pix .* sin(2*pi*Theta_deg/360);
0567 
0568 
0569 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%% SUB-FUNCTION %%%%%%%%%%%%%%%%%%%%%</span>
0570 <span class="comment">% Make a distance line</span>
0571 <a name="_sub6" href="#_subfunctions" class="code">function [x,y] = draw_the_distance(CenterPixel,Distance_pix,Theta_deg)</a>
0572 
0573 x(1)= CenterPixel(2);
0574 x(2)= CenterPixel(2) + Distance_pix .* cos(2*pi*Theta_deg/360);
0575 y(1)= CenterPixel(1);
0576 y(2)= CenterPixel(1) - Distance_pix .* sin(2*pi*Theta_deg/360);</pre></div>
<hr><address>Generated on Wed 22-Nov-2017 16:40:02 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>